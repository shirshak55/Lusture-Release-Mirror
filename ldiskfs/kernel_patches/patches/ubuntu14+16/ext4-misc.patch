diff --git a/fs/ext4/ext4.h b/fs/ext4/ext4.h
index 574a6c9..97d3432 100644
--- a/fs/ext4/ext4.h
+++ b/fs/ext4/ext4.h
@@ -1581,6 +1581,8 @@ static inline int ext4_encrypted_inode(struct inode *inode)
 
 #define NEXT_ORPHAN(inode) EXT4_I(inode)->i_dtime
 
+#define JOURNAL_START_HAS_3ARGS	1
+
 /*
  * Codes for operating systems
  */
@@ -1812,7 +1814,21 @@ static inline bool ext4_has_unknown_ext##ver##_incompat_features(struct super_bl
 
 EXTN_FEATURE_FUNCS(2)
 EXTN_FEATURE_FUNCS(3)
-EXTN_FEATURE_FUNCS(4)
+static inline bool ext4_has_unknown_ext4_compat_features(struct super_block *sb)
+{
+	return ((EXT4_SB(sb)->s_es->s_feature_compat &
+		cpu_to_le32(~EXT4_FEATURE_COMPAT_SUPP)) != 0);
+}
+static inline bool ext4_has_unknown_ext4_ro_compat_features(struct super_block *sb)
+{
+	return ((EXT4_SB(sb)->s_es->s_feature_ro_compat &
+		cpu_to_le32(~EXT4_FEATURE_RO_COMPAT_SUPP)) != 0);
+}
+static inline bool ext4_has_unknown_ext4_incompat_features(struct super_block *sb)
+{
+	return ((EXT4_SB(sb)->s_es->s_feature_incompat &
+		cpu_to_le32(~EXT4_FEATURE_INCOMPAT_SUPP)) != 0);
+}
 
 static inline bool ext4_has_compat_features(struct super_block *sb)
 {
@@ -3149,6 +3165,11 @@ struct ext4_extent;
 
 extern int ext4_ext_tree_init(handle_t *handle, struct inode *);
 extern int ext4_ext_writepage_trans_blocks(struct inode *, int);
+extern struct buffer_head *ext4_read_inode_bitmap(struct super_block *sb,
+						  ext4_group_t block_group);
+extern struct buffer_head *ext4_append(handle_t *handle,
+				       struct inode *inode,
+				       ext4_lblk_t *block);
 extern int ext4_ext_index_trans_blocks(struct inode *inode, int extents);
 extern int ext4_ext_map_blocks(handle_t *handle, struct inode *inode,
 			       struct ext4_map_blocks *map, int flags);
diff --git a/fs/ext4/ialloc.c b/fs/ext4/ialloc.c
index 38a740f..0cccda3 100644
--- a/fs/ext4/ialloc.c
+++ b/fs/ext4/ialloc.c
@@ -153,7 +153,7 @@ static int ext4_validate_inode_bitmap(struct super_block *sb,
  *
  * Return buffer_head of bitmap on success or NULL.
  */
-static struct buffer_head *
+struct buffer_head *
 ext4_read_inode_bitmap(struct super_block *sb, ext4_group_t block_group)
 {
 	struct ext4_group_desc *desc;
@@ -233,6 +233,7 @@ out:
 	put_bh(bh);
 	return ERR_PTR(err);
 }
+EXPORT_SYMBOL(ext4_read_inode_bitmap);
 
 /*
  * NOTE! When we get the inode, we're the only people
diff --git a/fs/ext4/inode.c b/fs/ext4/inode.c
index 296760b..04c5f63 100644
--- a/fs/ext4/inode.c
+++ b/fs/ext4/inode.c
@@ -5452,6 +5452,20 @@ out:
 	sb_end_pagefault(inode->i_sb);
 	return ret;
 }
+EXPORT_SYMBOL(ext4_map_blocks);
+EXPORT_SYMBOL(ext4_truncate);
+EXPORT_SYMBOL(ext4_iget);
+EXPORT_SYMBOL(ext4_bread);
+EXPORT_SYMBOL(ext4_itable_unused_count);
+EXPORT_SYMBOL(ext4_force_commit);
+EXPORT_SYMBOL(ext4_mark_inode_dirty);
+EXPORT_SYMBOL(ext4_get_group_desc);
+EXPORT_SYMBOL(__ext4_journal_get_write_access);
+EXPORT_SYMBOL(__ext4_journal_start_sb);
+EXPORT_SYMBOL(__ext4_journal_stop);
+EXPORT_SYMBOL(__ext4_handle_dirty_metadata);
+EXPORT_SYMBOL(__ext4_std_error);
+EXPORT_SYMBOL(ext4fs_dirhash);
 
 int ext4_filemap_fault(struct vm_area_struct *vma, struct vm_fault *vmf)
 {
diff --git a/fs/ext4/mballoc.c b/fs/ext4/mballoc.c
index 6bcf0ca..02368cb 100644
--- a/fs/ext4/mballoc.c
+++ b/fs/ext4/mballoc.c
@@ -723,7 +723,6 @@ void ext4_mb_generate_buddy(struct super_block *sb,
 				void *buddy, void *bitmap, ext4_group_t group)
 {
 	struct ext4_group_info *grp = ext4_get_group_info(sb, group);
-	struct ext4_sb_info *sbi = EXT4_SB(sb);
 	ext4_grpblk_t max = EXT4_CLUSTERS_PER_GROUP(sb);
 	ext4_grpblk_t i = 0;
 	ext4_grpblk_t first;
diff --git a/fs/ext4/namei.c b/fs/ext4/namei.c
index aaa388a..36635b6 100644
--- a/fs/ext4/namei.c
+++ b/fs/ext4/namei.c
@@ -47,7 +47,7 @@
 #define NAMEI_RA_BLOCKS  4
 #define NAMEI_RA_SIZE	     (NAMEI_RA_CHUNKS * NAMEI_RA_BLOCKS)
 
-static struct buffer_head *ext4_append(handle_t *handle,
+struct buffer_head *ext4_append(handle_t *handle,
 					struct inode *inode,
 					ext4_lblk_t *block)
 {
@@ -157,6 +157,7 @@ static struct buffer_head *__ext4_read_dirblock(struct inode *inode,
 	}
 	return bh;
 }
+EXPORT_SYMBOL(ext4_append);
 
 #ifndef assert
 #define assert(test) J_ASSERT(test)
@@ -2407,7 +2408,7 @@ EXPORT_SYMBOL(ext4_delete_entry);
  * DIR_NLINK feature is set if 1) nlinks > EXT4_LINK_MAX or 2) nlinks == 2,
  * since this indicates that nlinks count was previously 1.
  */
-static void ext4_inc_count(handle_t *handle, struct inode *inode)
+void ext4_inc_count(handle_t *handle, struct inode *inode)
 {
 	inc_nlink(inode);
 	if (is_dx(inode) && inode->i_nlink > 1) {
@@ -2418,16 +2419,18 @@ static void ext4_inc_count(handle_t *handle, struct inode *inode)
 		}
 	}
 }
+EXPORT_SYMBOL(ext4_inc_count);
 
 /*
  * If a directory had nlink == 1, then we should let it be 1. This indicates
  * directory has >EXT4_LINK_MAX subdirs.
  */
-static void ext4_dec_count(handle_t *handle, struct inode *inode)
+void ext4_dec_count(handle_t *handle, struct inode *inode)
 {
 	if (!S_ISDIR(inode->i_mode) || inode->i_nlink > 2)
 		drop_nlink(inode);
 }
+EXPORT_SYMBOL(ext4_dec_count);
 
 
 static int ext4_add_nondir(handle_t *handle,
